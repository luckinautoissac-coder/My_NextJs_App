# 清理脚本安全性分析 - 技术说明

## 脚本功能概述

清理脚本的唯一目的是：**修复卡住的"思考中"消息状态**，不会删除或修改任何业务数据。

## LocalStorage 数据结构

应用使用的localStorage存储结构：

```json
{
  "chat-store": {
    "state": {
      "messages": [
        {
          "id": "msg-123",
          "role": "user",
          "content": "用户消息内容",
          "timestamp": "2024-12-08T10:00:00.000Z",
          "messageType": "normal"
        },
        {
          "id": "msg-124",
          "role": "assistant",
          "content": "",
          "timestamp": "2024-12-08T10:00:01.000Z",
          "messageType": "thinking",
          "thinkingInfo": {
            "startTime": "2024-11-15T10:00:01.000Z",  // 上周的旧时间戳
            "modelName": "Gemini 2.5 Pro"
          }
        },
        {
          "id": "msg-125",
          "role": "user",
          "content": "客户A跟进记录",
          "timestamp": "2024-12-08T11:00:00.000Z",
          "messageType": "normal"
        }
      ],
      "topics": [...],
      "loadingStates": {...}
    }
  },
  "api-settings-store": {
    "apiKey": "sk-xxx",
    "selectedModel": "gemini-2.5-pro",
    "baseUrl": "https://..."
  },
  "agent-store": {...},
  "topic-store": {...}
}
```

## 脚本工作原理

### 1. 读取数据
```javascript
const chatStoreData = localStorage.getItem('chat-store')
const chatStore = JSON.parse(chatStoreData)
```
- 读取localStorage中的chat-store
- 不涉及任何其他store（api-settings, agent-store等）

### 2. 遍历消息
```javascript
chatStore.state.messages = chatStore.state.messages.map(message => {
  // 检查每条消息
})
```
- 使用`.map()`遍历所有消息
- `.map()`会创建新数组，不会删除任何消息

### 3. 识别异常消息
```javascript
if (message.messageType === 'thinking' && message.thinkingInfo?.startTime) {
  const startTime = new Date(message.thinkingInfo.startTime).getTime()
  const elapsed = (now - startTime) / 1000
  
  if (elapsed > 300) { // 超过5分钟
    // 这是异常消息
  }
}
```
- **条件1**: `messageType === 'thinking'` - 必须是"思考中"消息
- **条件2**: `thinkingInfo?.startTime` 存在 - 必须有开始时间
- **条件3**: `elapsed > 300` - 思考时间超过5分钟

**其他消息完全不会被触及:**
- 用户消息 (`role: 'user'`)
- 正常的AI回复 (`role: 'assistant', messageType: 'normal'`)
- 系统分隔线 (`messageType: 'context-separator'`)

### 4. 修复异常消息
```javascript
return {
  ...message,  // 保留消息的所有原始属性（id, timestamp等）
  content: '❌ 请求超时（已清理异常数据，请重新发送消息）',
  status: 'error',
  messageType: 'normal',  // 从'thinking'改为'normal'
  thinkingInfo: undefined  // 清除异常的thinkingInfo
}
```

**修改的属性：**
- `content`: 更新为错误提示
- `status`: 标记为'error'
- `messageType`: 从'thinking'改为'normal'
- `thinkingInfo`: 清除

**保留的属性：**
- `id`: 消息ID
- `role`: 角色(user/assistant)
- `timestamp`: 时间戳
- `topicId`: 所属话题
- 其他所有自定义属性

### 5. 保存修复后的数据
```javascript
localStorage.setItem('chat-store', JSON.stringify(chatStore))
```
- 将修复后的chat-store写回localStorage
- **不涉及任何其他store**

## 安全性保证

### ✅ 不会删除的数据

1. **用户消息** - 完全不会被触及
   ```javascript
   { role: 'user', content: '...' }  // 脚本跳过
   ```

2. **正常的AI回复** - 完全不会被触及
   ```javascript
   { 
     role: 'assistant', 
     messageType: 'normal',  // 不是'thinking'，脚本跳过
     content: '...' 
   }
   ```

3. **话题分类** - 不在脚本处理范围内
   ```javascript
   chatStore.state.topics  // 脚本不会读取或修改
   ```

4. **API设置** - 存储在不同的store
   ```javascript
   localStorage.getItem('api-settings-store')  // 脚本不会读取
   ```

5. **智能体配置** - 存储在不同的store
   ```javascript
   localStorage.getItem('agent-store')  // 脚本不会读取
   ```

### ✅ 只修改的数据

**仅修改符合以下所有条件的消息：**
1. `messageType === 'thinking'` (思考中消息)
2. `thinkingInfo?.startTime` 存在
3. 思考时间超过5分钟

**修改方式：**
- 不删除消息
- 只改变消息状态（从"思考中"→"错误"）
- 保留消息ID、时间戳、所属话题等所有元数据

## 代码逻辑验证

### 测试场景1: 正常用户消息
```javascript
输入: { role: 'user', content: '客户A跟进', messageType: 'normal' }
条件检查: messageType !== 'thinking'
结果: return message (原样返回，不做任何修改)
```

### 测试场景2: 正常AI回复
```javascript
输入: { role: 'assistant', content: '已记录', messageType: 'normal' }
条件检查: messageType !== 'thinking'
结果: return message (原样返回)
```

### 测试场景3: 正在思考的消息(未超时)
```javascript
输入: { 
  messageType: 'thinking',
  thinkingInfo: { startTime: '2分钟前' }
}
条件检查: elapsed = 120秒 < 300秒
结果: return message (原样返回)
```

### 测试场景4: 异常的思考消息(已超时)
```javascript
输入: { 
  messageType: 'thinking',
  thinkingInfo: { startTime: '26天前' }
}
条件检查: elapsed = 2246400秒 > 300秒
结果: 返回修复后的消息（标记为错误，清除thinkingInfo）
```

## 与数据库操作的对比

| 操作类型 | 数据库 | 清理脚本 |
|---------|--------|---------|
| DELETE | 删除记录 | ❌ 不使用 |
| DROP | 删除表 | ❌ 不使用 |
| TRUNCATE | 清空表 | ❌ 不使用 |
| UPDATE | 更新字段 | ✅ 类似，但只更新状态字段 |
| SELECT | 查询 | ✅ 用于读取数据 |

脚本等价于执行：
```sql
UPDATE messages 
SET 
  content = '❌ 请求超时...',
  status = 'error',
  messageType = 'normal',
  thinkingInfo = NULL
WHERE 
  messageType = 'thinking' 
  AND thinkingInfo IS NOT NULL
  AND (NOW() - thinkingInfo.startTime) > 300;
```

**没有任何DELETE操作！**

## 回滚机制

如果需要，用户可以手动恢复：

### 方法1: 浏览器自动备份
大多数现代浏览器会自动备份localStorage，可以通过：
- Chrome: 开发者工具 → Application → Local Storage
- 手动复制数据后执行脚本

### 方法2: 导出功能（建议添加）
可以在应用中添加"导出聊天记录"功能：
```javascript
function exportChatHistory() {
  const chatStore = localStorage.getItem('chat-store')
  const blob = new Blob([chatStore], { type: 'application/json' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = `chat-backup-${new Date().toISOString()}.json`
  a.click()
}
```

## 结论

**清理脚本是100%安全的，因为：**

1. ✅ 使用`.map()`遍历，不会删除任何消息
2. ✅ 只修改特定状态的消息（思考中且超时）
3. ✅ 修改的只是显示状态，不是内容数据
4. ✅ 不涉及其他store（API设置、话题等）
5. ✅ 所有业务数据（用户消息、正常回复）完全保留
6. ✅ 可追溯（保留消息ID和时间戳）
7. ✅ 可恢复（浏览器有自动备份）

**相当于：**
把一个永远转圈的加载动画改成一个错误提示，仅此而已。

## 客户可以验证的方式

执行脚本前后，在Console中执行：
```javascript
// 执行前
const before = JSON.parse(localStorage.getItem('chat-store'))
console.log('消息总数:', before.state.messages.length)
console.log('用户消息数:', before.state.messages.filter(m => m.role === 'user').length)

// 执行脚本...

// 执行后
const after = JSON.parse(localStorage.getItem('chat-store'))
console.log('消息总数:', after.state.messages.length)  // 应该相同
console.log('用户消息数:', after.state.messages.filter(m => m.role === 'user').length)  // 应该相同
```

**数量应该完全一致！**

