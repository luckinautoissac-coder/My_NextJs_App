# 立即解决存储空间问题 - 临时方案

## 🚨 当前客户问题

客户遇到 `exceeded the quota` 错误，无法继续使用。

## ⚡ 立即解决方案（5分钟内）

### 方案A: 智能清理脚本（推荐，保留重要数据）

让客户在 Console 中执行以下脚本：

```javascript
(function() {
  console.log('=== 智能清理存储空间 ===\n')
  
  try {
    // 1. 读取数据
    const chatStore = JSON.parse(localStorage.getItem('chat-store') || '{}')
    
    if (!chatStore.state || !chatStore.state.messages) {
      console.log('❌ 数据格式异常')
      return
    }
    
    const originalCount = chatStore.state.messages.length
    const originalSize = (JSON.stringify(chatStore).length / 1024).toFixed(2)
    
    console.log(`📊 当前状态:`)
    console.log(`   消息总数: ${originalCount}`)
    console.log(`   存储大小: ${originalSize} KB\n`)
    
    // 2. 清理策略：保留最近15天
    const keepDays = 15
    const cutoffDate = new Date()
    cutoffDate.setDate(cutoffDate.getDate() - keepDays)
    
    console.log(`⏰ 将保留最近 ${keepDays} 天的对话\n`)
    
    // 3. 过滤消息
    chatStore.state.messages = chatStore.state.messages.filter(message => {
      const messageDate = new Date(message.timestamp)
      return messageDate >= cutoffDate
    })
    
    // 4. 清理异常的思考消息
    chatStore.state.messages = chatStore.state.messages.map(message => {
      if (message.messageType === 'thinking' && message.thinkingInfo?.startTime) {
        const now = new Date().getTime()
        const startTime = new Date(message.thinkingInfo.startTime).getTime()
        const elapsed = (now - startTime) / 1000
        
        if (elapsed > 300) {
          return {
            ...message,
            content: '❌ 请求超时（已清理）',
            status: 'error',
            messageType: 'normal',
            thinkingInfo: undefined
          }
        }
      }
      return message
    })
    
    // 5. 保存
    const newData = JSON.stringify(chatStore)
    const newSize = (newData.length / 1024).toFixed(2)
    const deletedCount = originalCount - chatStore.state.messages.length
    const savedSize = (originalSize - newSize).toFixed(2)
    
    try {
      localStorage.setItem('chat-store', newData)
      
      console.log(`✅ 清理完成！`)
      console.log(`   删除消息数: ${deletedCount}`)
      console.log(`   保留消息数: ${chatStore.state.messages.length}`)
      console.log(`   原始大小: ${originalSize} KB`)
      console.log(`   清理后: ${newSize} KB`)
      console.log(`   释放空间: ${savedSize} KB\n`)
      
      console.log('⏳ 1秒后自动刷新...')
      setTimeout(() => location.reload(), 1000)
      
    } catch (error) {
      console.error('❌ 存储仍然不足，尝试更激进的清理...\n')
      
      // 如果15天还不够，尝试7天
      const keepDays2 = 7
      const cutoffDate2 = new Date()
      cutoffDate2.setDate(cutoffDate2.getDate() - keepDays2)
      
      chatStore.state.messages = chatStore.state.messages.filter(message => {
        const messageDate = new Date(message.timestamp)
        return messageDate >= cutoffDate2
      })
      
      try {
        localStorage.setItem('chat-store', JSON.stringify(chatStore))
        console.log(`✅ 清理完成（保留最近${keepDays2}天）！`)
        setTimeout(() => location.reload(), 1000)
      } catch (error2) {
        console.error('❌ 存储空间严重不足，请使用方案B')
        console.log('\n💡 请执行: clearAllMessages()')
      }
    }
    
  } catch (error) {
    console.error('❌ 清理失败:', error)
  }
})()

// 定义清空所有消息的函数（保留设置）
window.clearAllMessages = function() {
  if (!confirm('确定要清空所有聊天记录吗？（设置和配置会保留）')) {
    return
  }
  
  const chatStore = JSON.parse(localStorage.getItem('chat-store') || '{}')
  chatStore.state = {
    messages: [],
    topics: chatStore.state?.topics || [],
    loadingStates: {}
  }
  
  localStorage.setItem('chat-store', JSON.stringify(chatStore))
  alert('已清空聊天记录，即将刷新')
  setTimeout(() => location.reload(), 500)
}

console.log('\n💡 如果自动清理不够，可以手动执行: clearAllMessages()')
```

### 方案B: 导出后清空（最安全）

```javascript
(function() {
  console.log('=== 导出数据并清空 ===\n')
  
  // 1. 导出所有数据
  const allData = {}
  for (let key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      allData[key] = localStorage.getItem(key)
    }
  }
  
  // 2. 创建下载链接
  const dataStr = JSON.stringify(allData, null, 2)
  const blob = new Blob([dataStr], { type: 'application/json' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = `chat-backup-${new Date().toISOString().slice(0,10)}.json`
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
  
  console.log('✅ 数据已导出，请查看下载文件')
  console.log('💡 确认文件下载成功后，执行以下命令清空：\n')
  console.log('clearAndRestart()\n')
  
  window.clearAndRestart = function() {
    if (!confirm('确定要清空所有数据并重新开始吗？\n（请确保已下载备份文件）')) {
      return
    }
    
    // 保存 API Key
    const apiKey = localStorage.getItem('api-settings-store')
    
    // 清空所有
    localStorage.clear()
    
    // 恢复 API Key
    if (apiKey) {
      localStorage.setItem('api-settings-store', apiKey)
    }
    
    alert('已清空数据，即将刷新')
    location.reload()
  }
})()
```

### 方案C: 最激进清理（保留API设置）

```javascript
(function() {
  if (!confirm('确定要清空所有聊天记录吗？\n（API设置和智能体配置会保留）')) {
    return
  }
  
  console.log('=== 清空聊天记录 ===\n')
  
  // 备份关键设置
  const apiSettings = localStorage.getItem('api-settings-store')
  const agentStore = localStorage.getItem('agent-store')
  const topicStore = localStorage.getItem('topic-store')
  const thinkingChain = localStorage.getItem('thinking-chain-store')
  
  // 清空 chat-store
  localStorage.setItem('chat-store', JSON.stringify({
    state: {
      messages: [],
      topics: [],
      loadingStates: {}
    },
    version: 0
  }))
  
  console.log('✅ 聊天记录已清空')
  console.log('✅ API设置已保留')
  console.log('✅ 智能体配置已保留')
  console.log('\n⏳ 1秒后刷新...')
  
  setTimeout(() => location.reload(), 1000)
})()
```

## 📊 方案对比

| 方案 | 数据保留 | 风险 | 推荐度 |
|------|---------|------|--------|
| A - 智能清理 | 最近15天 | 低 | ⭐⭐⭐⭐⭐ |
| B - 导出清空 | 全部导出 | 无 | ⭐⭐⭐⭐ |
| C - 激进清理 | 设置保留 | 中 | ⭐⭐⭐ |

## 🎯 使用建议

### 情况1：客户有重要跟进记录
使用**方案B**（导出后清空），最安全。

### 情况2：客户可以接受保留最近数据
使用**方案A**（智能清理），最方便。

### 情况3：客户急需立即使用
使用**方案C**（激进清理），最快速。

## ⚠️ 注意事项

1. **执行前告知客户**会删除哪些数据
2. **方案A和C不可逆**，删除的数据无法恢复
3. **方案B需要确认**下载的备份文件完整
4. 所有方案都会**保留API设置**

## 📞 客户沟通模板

```
您好！检测到存储空间已满，需要清理才能继续使用。

我们提供3种方案：

1. 【推荐】智能清理：自动删除15天前的对话，保留最近的记录
2. 【最安全】导出后清空：先下载所有数据备份，然后清空
3. 【最快】清空重来：清空所有对话，保留您的API设置

请告诉我选择哪个方案，我会发送具体操作步骤。

所有方案都会保留：
✅ API Key
✅ 智能体配置
✅ 其他设置
```

## 🚀 后续行动

立即问题解决后，建议：
1. 部署 IndexedDB 方案（长期解决）
2. 添加自动清理功能
3. 添加存储空间监控
4. 提供数据导出功能

详见：`IndexedDB迁移部署指南.md`

